# 性能优化说明

## 问题
之前的实现会一次性加载和渲染所有文件，对于大量文件（如数百个手记条目）会造成：
- 内存占用过高
- 初始加载时间过长
- 界面卡顿
- 浏览器压力过大

## 优化方案

### 1. **分页加载（Pagination）**
- **每页加载 20 个条目**（可在代码中调整 `itemsPerPage`）
- 初始只渲染第一页内容
- 滚动到底部时自动加载下一页
- 使用 Intersection Observer API 检测是否需要加载更多

### 2. **懒加载图片（Lazy Loading）**
- 图片使用浏览器原生 `loading="lazy"` 属性
- 使用 Intersection Observer 实现更精确的懒加载控制
- 图片只在进入视口前 50px 时开始加载
- 使用 `decoding="async"` 异步解码，不阻塞渲染

### 3. **元数据优先加载**
- 初始只加载文件元数据（日期、图片路径、字数、预览）
- **不加载完整文件内容**，需要时再加载
- 批量处理文件（每批 10 个），避免一次性处理过多

### 4. **增量渲染**
- 只渲染可见区域的卡片
- 使用 `renderedEntries` Set 跟踪已渲染的条目，避免重复渲染
- 按月份分组时，复用已存在的月份容器

## 性能提升

### 之前（一次性加载）
- 100 个文件：加载所有内容，渲染所有卡片
- 内存占用：高（所有文件内容在内存中）
- 初始渲染时间：5-10 秒

### 现在（分页+懒加载）
- 100 个文件：初始只加载元数据，渲染前 20 个卡片
- 内存占用：低（只保存元数据，内容按需加载）
- 初始渲染时间：< 1 秒

## 配置选项

可以在 `JournalView.ts` 中调整：

```typescript
private itemsPerPage: number = 20; // 每页加载的条目数
```

建议值：
- 小量文件（< 50）：20-30
- 中量文件（50-200）：15-20
- 大量文件（> 200）：10-15

## 技术细节

### Intersection Observer
用于检测元素是否进入视口，比滚动事件更高效：
- 浏览器原生 API，性能好
- 自动管理，无需手动计算位置
- 支持 `rootMargin` 提前触发

### 批量处理
使用 `Promise.all` 批量处理文件，但限制并发数：
- 避免同时打开过多文件句柄
- 控制内存峰值
- 提供进度反馈

## 未来优化方向

1. **虚拟滚动**：只渲染可见区域的 DOM 元素
2. **缓存机制**：缓存已加载的文件内容
3. **Web Worker**：在后台线程处理文件解析
4. **索引数据库**：使用 IndexedDB 存储元数据
